public class TextEditorBackgroundTask : IBackgroundTask
{
	/// <summary>
	/// The group of properties which are implemented from 'IBackgroundTask'
	/// </summary>
	public Key<BackgroundTask> BackgroundTaskKey { get; }
    public Key<BackgroundTaskQueue> QueueKey { get; }
    public string Name { get; }
    public Task? WorkProgress { get; }
	public TimeSpan ThrottleTimeSpan { get; }

	/// <summary>
	/// The group of properties which provide data on which
	/// the <see cref="InternalEditTask"/> and <see cref="ExternalEditTaskList"/>
	/// enact edits to.
	/// </summary>
	public ITextEditorService TextEditorService { get; }	
	public ITextEditorEditContext? EditContext { get; }

	/// <summary>
	/// The task which originally was assigned to this object instance.
	/// </summary>
	public TextEditorEdit InternalEditTask { get; }

	/// <summary>
	/// The list of any tasks that were eligible to run
	/// using this task's 'ITextEditorEditContext'.
	/// </summary>
	public List<TextEditorEdit> ExternalEditTaskList { get; }

	public IBackgroundTask? BatchOrDefault(IBackgroundTask oldEvent)
	{
		// This method is invoked from within a semaphore,
		// of which blocks the queue from being processed.
		//
		// So, if we see that the last enqueued item
		// is of this same 'Type', we can share the 'ITextEditorEditContext'
		//
		// By sharing the 'EditContext' amongst two tasks, we reduce
		// 2 UI renders down to only 1.
		if (oldEvent is TextEditorBackgroundTask oldTextEditorBackgroundTask)
		{
		}
	}
	
	public Task HandleEvent(CancellationToken cancellationToken)
	{
		EditContext ??= TextEditorService.OpenEditContext();

		InternalEditTask.Invoke(EditContext).ConfigureAwait(false);

		foreach (var externalEditTask in ExternalEditTaskList)
		{
			externalEditTask.Invoke(EditContext).ConfigureAwait(false);
		}

		TextEditorService.CloseEditContext();
	}
}

