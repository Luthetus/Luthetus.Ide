@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax
@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Symbols
@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Nodes
@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Nodes.Interfaces
@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Nodes.Enums

@code {
	public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetVariableSymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is IVariableDeclarationNode variableDeclarationNode)
    	{
    		<text>
    			@if (driver.Symbol is not null)
    			{
                	<span>(local)</span>
                }
                
                @GetTypeClauseNodeSymbolRenderFragment(variableDeclarationNode.TypeClauseNode)
                
                <span class="luth_te_variable">&nbsp;@variableDeclarationNode.IdentifierToken.TextSpan.GetText()</span>
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(local)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_variable">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
	</text>;
	
	public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetFieldSymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is IVariableDeclarationNode variableDeclarationNode)
    	{
    		<text>
                <span>(field)</span>
                @GetTypeClauseNodeSymbolRenderFragment(variableDeclarationNode.TypeClauseNode)
                <span class="luth_te_field">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(field)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_field">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
	</text>;
	
	public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetPropertySymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is IVariableDeclarationNode variableDeclarationNode)
    	{
    		<text>
                <span>(property)</span>
                @GetTypeClauseNodeSymbolRenderFragment(variableDeclarationNode.TypeClauseNode)
                <span class="luth_te_property">@driver.Symbol.TextSpan.GetText()</span>
                
                @if (variableDeclarationNode.VariableKind == VariableKind.Property)
                {
                	<span>
	                	{
	                	
	                	@if (variableDeclarationNode.HasGetter)
	                	{
	                		<text><span class="luth_te_keyword"> get</span>;</text>
	                	}
	                	
	                	@if (variableDeclarationNode.HasSetter)
	                	{
	                		<text><span class="luth_te_keyword"> set</span>;</text>
	                	}
	                	
	                	}
                	</span>
                }
                
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(property)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_property">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
	</text>;
	
	public static RenderFragment<TypeClauseNode> GetTypeClauseNodeSymbolRenderFragment = driverTypeClauseNode => 
	@<text>
		<span style="display: inline-flex;">

			@{
				var parameter = (
					"luth_te_type",                                               // ClassCssString
					@driverTypeClauseNode.TypeIdentifierToken.TextSpan.GetText(), // Text
					@driverTypeClauseNode.TypeIdentifierToken.TextSpan);          // TextSpan
			}
		
			<SymbolOnClick Parameter='parameter'/>
			
			@if (driverTypeClauseNode.GenericParametersListingNode is not null)
			{
				<text>&lt;</text>
				
				@for (int badIndex = 0; badIndex < driverTypeClauseNode.GenericParametersListingNode.GenericParameterEntryNodeList.Count; badIndex++)
				{
					var index = badIndex;
					var genericParameter = driverTypeClauseNode.GenericParametersListingNode.GenericParameterEntryNodeList[index];
					
					@GetTypeClauseNodeSymbolRenderFragment(genericParameter.TypeClauseNode)
					
					if (index < driverTypeClauseNode.GenericParametersListingNode.GenericParameterEntryNodeList.Count - 1)
					{
						<text>,</text>
					}
				}
				
				<text>&gt;</text>
			}
			
			@if (driverTypeClauseNode.HasQuestionMark)
			{
				<text>?</text>
			}
		</span>
	</text>;
	
	public static RenderFragment<TypeDefinitionNode> GetTypeDefinitionNodeSymbolRenderFragment = driverTypeDefinitionNode => 
	@<text>
		<span style="display: inline-flex;">

			namespace.here.
			
			@GetTypeClauseNodeSymbolRenderFragment(driverTypeDefinitionNode.ToTypeClause())
		</span>
	</text>;
	
	public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetConstructorDefinitionNodeSymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is ConstructorDefinitionNode constructorDefinitionNode)
    	{
    		<text>
                <span>(constructor)</span>
                <span class="luth_te_type">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(constructor)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_type">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
    </text>;
    
    public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetFunctionSymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is FunctionDefinitionNode functionDefinitionNode)
    	{
    		<text>
                <span>(function)</span>
                
                <span style="display: inline-flex;">
                	<span class="luth_te_method">@driver.Symbol.TextSpan.GetText()</span>
                
	                <span style="display: inline-flex;">
	                	(
	                	
	                	@for (int badIndex = 0; badIndex < functionDefinitionNode.FunctionArgumentsListingNode.FunctionArgumentEntryNodeList.Count; badIndex++)
	                	{
	                		var index = badIndex;
	                		
	                		var functionArgumentEntryNode = functionDefinitionNode.FunctionArgumentsListingNode.FunctionArgumentEntryNodeList[index];
	                		@GetVariableSymbolRenderFragment((null, functionArgumentEntryNode.VariableDeclarationNode))
	                		
	                		if (index < functionDefinitionNode.FunctionArgumentsListingNode.FunctionArgumentEntryNodeList.Count - 1)
	                		{
	                			<text>,&nbsp;</text>
	                		}
	                	}
	                	
	                	)
	                </span>
                </span>
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(function)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_method">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
    </text>;
    
    public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetLambdaSymbolRenderFragment = driver => 
	@<text>
	    <span class="luth_te_keyword">lambda</span><!--
	    
	    -->:<br/>
	
	    <span class="@(string.Empty /* Lambdas do not have their own css class as of (2024-11-02) */)">
	    	
	    	@{ var lambdaSymbol = (LambdaSymbol)driver.Symbol; }
	    	
	    	<!--
	    		This UI for the lambda is super odd to read. I'm working on the lambda parsing and I can't remember off the top of my head how to get rid of a space between
	    		UI elements and I'm not done with the parsing so I really don't wanna waste anytime on this I just put a bunch of comments to line them together.
	    	-->
	    	<span>
	        	(<!--
	        	-->@for (int i = 0; i < lambdaSymbol.LambdaExpressionNode.VariableDeclarationNodeList.Count; i++)
	        	{<!--
	        		-->var index = i;<!--
	        		-->var variableDeclarationNode = lambdaSymbol.LambdaExpressionNode.VariableDeclarationNodeList[index];<!--
	        		--><text><!--
	        			--><span class="luth_te_type">@variableDeclarationNode.TypeClauseNode.TypeIdentifierToken.TextSpan.GetText()</span> <span class="luth_te_variable">@variableDeclarationNode.IdentifierToken.TextSpan.GetText()</span><!--
	        			-->@if (index < lambdaSymbol.LambdaExpressionNode.VariableDeclarationNodeList.Count - 1)
	        			{<!--
	        				--><text>, </text><!--
	        			-->}<!--
	        		--></text><!--
	        	-->}<!--
	        	-->)
	    	</span>
	    	
	    	@* => *@
	        @driver.Symbol.TextSpan.GetText()
	        
	        @if (lambdaSymbol.LambdaExpressionNode.CodeBlockNodeIsExpression)
	        {
	        	<text> ...;</text>
	        }
	        else
	        {
	        	<text> {...}</text>
	        }
	    </span>
	</text>;
}
