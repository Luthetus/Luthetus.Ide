@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax
@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Symbols
@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Nodes
@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Nodes.Interfaces
@using Luthetus.TextEditor.RazorLib.CompilerServices.Syntax.Nodes.Enums
@using Luthetus.TextEditor.RazorLib.TextEditors.Models.Internals
@using Luthetus.TextEditor.RazorLib.TextEditors.Displays.Internals.Symbols;

@code {
	
	
	public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetFieldSymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is IVariableDeclarationNode variableDeclarationNode)
    	{
    		<text>
                <span>(field)</span>
                
                @{
                	var syntaxViewModel = new SyntaxViewModel(
                		symbol: null,
                		targetNode: variableDeclarationNode.TypeClauseNode,
                		definitionNode: null);
                }
                <TypeSyntaxDisplay SyntaxViewModel="syntaxViewModel"/>
                
                <span class="luth_te_field">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(field)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_field">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
	</text>;
	
	public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetPropertySymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is IVariableDeclarationNode variableDeclarationNode)
    	{
    		<text>
                <span>(property)</span>
                
                @{
                	var syntaxViewModel = new SyntaxViewModel(
                		symbol: null,
                		targetNode: variableDeclarationNode.TypeClauseNode,
                		definitionNode: null);
                }
                <TypeSyntaxDisplay SyntaxViewModel="syntaxViewModel"/>
                
                <span class="luth_te_property">@driver.Symbol.TextSpan.GetText()</span>
                
                @if (variableDeclarationNode.VariableKind == VariableKind.Property)
                {
                	<span>
	                	{
	                	
	                	@if (variableDeclarationNode.HasGetter)
	                	{
	                		<text><span class="luth_te_keyword"> get</span>;</text>
	                	}
	                	
	                	@if (variableDeclarationNode.HasSetter)
	                	{
	                		<text><span class="luth_te_keyword"> set</span>;</text>
	                	}
	                	
	                	}
                	</span>
                }
                
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(property)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_property">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
	</text>;
	
	public static RenderFragment<TypeDefinitionNode> GetTypeDefinitionNodeSymbolRenderFragment = driverTypeDefinitionNode => 
	@<text>
		<span style="display: inline-flex;">

			namespace.here.
			
			@{
            	var syntaxViewModel = new SyntaxViewModel(
            		symbol: null,
            		targetNode: driverTypeDefinitionNode.ToTypeClause(),
            		definitionNode: null);
            }
            <TypeSyntaxDisplay SyntaxViewModel="syntaxViewModel"/>
		</span>
	</text>;
	
	public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetConstructorDefinitionNodeSymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is ConstructorDefinitionNode constructorDefinitionNode)
    	{
    		<text>
                <span>(constructor)</span>
                <span class="luth_te_type">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(constructor)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_type">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
    </text>;
    
    public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetFunctionSymbolRenderFragment = driver => 
	@<text>
		@if (driver.Node is FunctionDefinitionNode functionDefinitionNode)
    	{
    		<text>
                <span>(function)</span>
                
                @{
	            	var syntaxViewModel = new SyntaxViewModel(
	            		symbol: null,
	            		targetNode: functionDefinitionNode.ReturnTypeClauseNode,
	            		definitionNode: null);
	            }
	            <TypeSyntaxDisplay SyntaxViewModel="syntaxViewModel"/>
                
                <span style="display: inline-flex;">
                	<span class="luth_te_method">@driver.Symbol.TextSpan.GetText()</span>
                
	                <span style="display: inline-flex;">
	                	(
	                	
	                	@for (int badIndex = 0; badIndex < functionDefinitionNode.FunctionArgumentsListingNode.FunctionArgumentEntryNodeList.Count; badIndex++)
	                	{
	                		var index = badIndex;
	                		
	                		var functionArgumentEntryNode = functionDefinitionNode.FunctionArgumentsListingNode.FunctionArgumentEntryNodeList[index];
	                		
	                		<text>GetVariableSymbolRenderFragment was here</text>
	                		// @GetVariableSymbolRenderFragment((null, functionArgumentEntryNode.VariableDeclarationNode))
	                		
	                		if (index < functionDefinitionNode.FunctionArgumentsListingNode.FunctionArgumentEntryNodeList.Count - 1)
	                		{
	                			<text>,&nbsp;</text>
	                		}
	                	}
	                	
	                	)
	                </span>
                </span>
            </text>
    	}
    	else
    	{
    		<text>
    			<span>(function)</span>
                <span class="luth_te_keyword">undefined</span>
                <span class="luth_te_method">@driver.Symbol.TextSpan.GetText()</span>
            </text>
    	}
    </text>;
    
    public static RenderFragment<(ISymbol Symbol, ISyntaxNode Node)> GetLambdaSymbolRenderFragment = driver => 
	@<text>
	    <span class="luth_te_keyword">lambda</span><!--
	    
	    -->:<br/>
	
	    <span class="@(string.Empty /* Lambdas do not have their own css class as of (2024-11-02) */)">
	    	
	    	@{ var lambdaSymbol = (LambdaSymbol)driver.Symbol; }
	    	
	    	<!--
	    		This UI for the lambda is super odd to read. I'm working on the lambda parsing and I can't remember off the top of my head how to get rid of a space between
	    		UI elements and I'm not done with the parsing so I really don't wanna waste anytime on this I just put a bunch of comments to line them together.
	    	-->
	    	<span>
	        	(<!--
	        	-->@for (int i = 0; i < lambdaSymbol.LambdaExpressionNode.VariableDeclarationNodeList.Count; i++)
	        	{<!--
	        		-->var index = i;<!--
	        		-->var variableDeclarationNode = lambdaSymbol.LambdaExpressionNode.VariableDeclarationNodeList[index];<!--
	        		--><text><!--
	        			--><span class="luth_te_type">@variableDeclarationNode.TypeClauseNode.TypeIdentifierToken.TextSpan.GetText()</span> <span class="luth_te_variable">@variableDeclarationNode.IdentifierToken.TextSpan.GetText()</span><!--
	        			-->@if (index < lambdaSymbol.LambdaExpressionNode.VariableDeclarationNodeList.Count - 1)
	        			{<!--
	        				--><text>, </text><!--
	        			-->}<!--
	        		--></text><!--
	        	-->}<!--
	        	-->)
	    	</span>
	    	
	    	@* => *@
	        @driver.Symbol.TextSpan.GetText()
	        
	        @if (lambdaSymbol.LambdaExpressionNode.CodeBlockNodeIsExpression)
	        {
	        	<text> ...;</text>
	        }
	        else
	        {
	        	<text> {...}</text>
	        }
	    </span>
	</text>;
}
